<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualBasic" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualBasic.FileIO" #>
<#@ output extension=".cs" #>
<# WriteLine(string.Format("//{0}",System.IO.Path.GetFileName(this.Host.TemplateFile))); #>
//---------------------------------------------------------------------------------
//This code was generated by a tool. Any changes or edits to its content will be lost.
<# WriteLine(string.Format("//{0:MM/dd/yyyy HH:mm:ss}",DateTime.Now)); #>
//
using System;
using System.Linq;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using Xceed.Wpf.Toolkit.PropertyGrid.Attributes;

namespace Mil2525.Fields {

    using Mil2525.Domains;

    public partial class SymbolSet {

        public SymbolSet() {
        }

        public SymbolSet(string schemaName, string schemaNameAlias, int symbolSetID) {
            SchemaName = schemaName;
            SchemaNameAlias = schemaNameAlias;
            SymbolSetID = symbolSetID;
        }

        public string SchemaName { get; set; }
        public string SchemaNameAlias { get; set; }
        public int SymbolSetID { get; set; }

        public string DisplayString => string.Format("{0}, Symbolset ID: {1:00}", SchemaName, SymbolSetID);
    }

    public abstract partial class Fields_Base : INotifyPropertyChanged {

	    protected Dictionary<string, object> _dictionaryFormattedValues = new Dictionary<string, object>();
        protected Dictionary<string, object> _dictionaryValues = new Dictionary<string, object>();
        protected string _schemaName = "";
        protected string _symbolSetName = "";

        public event PropertyChangedEventHandler PropertyChanged = delegate { };

        [Browsable(false)]
        public Dictionary<string, object> ChangedAttributeValues => _dictionaryValues;

		[Browsable(false)]
		public Dictionary<string, object> ChangedAttributeFormattedValues => _dictionaryFormattedValues;

        [Browsable(false)]
        public string SchemaName => _schemaName;

        [Browsable(false)]
        public string SymbolSetName => _symbolSetName;

		public virtual void ChangeAttributeValues(Dictionary<string, object> attributes) {
            var props = this.GetType().GetProperties().ToLookup(prop => prop.Name.ToLower());
            foreach (var kvp in attributes) {
                var prop = props[kvp.Key.ToLower()].FirstOrDefault();
                if (prop != null && prop.CanWrite) {
                    prop.SetValue(this, kvp.Value);
                }
            }
        }

        public virtual Dictionary<string, object> GetAttributeValues() {
            return this.GetType().GetProperties().ToDictionary(prop => prop.Name.ToLower(), prop => prop.GetValue(this));
        }


        protected virtual void OnPropertyChanged(object value = null, object formattedValue = null, [CallerMemberName] string propName = "") {
            _dictionaryValues[propName] = value;
			if (formattedValue == null)
				formattedValue = value;
			_dictionaryFormattedValues[propName] = formattedValue;
            PropertyChanged(this, new PropertyChangedEventArgs(propName));
        }
    }

	<#

	List<Tuple<string, string, int>> _fieldSets = new List<Tuple<string, string, int>>() {
		     new Tuple<string, string, int>("Air","Air",1),
			 new Tuple<string, string, int>("Air (Missile)","Air Missile",2),
			 new Tuple<string, string, int>("Space", "Space Equipment, Platform, and Missile", 5),
			 new Tuple<string, string, int>("Space (Missile)","Space Equipment, Platform, and Missile",6),
			 new Tuple<string, string, int>("Units", "Land Units", 10),
			 new Tuple<string, string, int>("Civilian","Civilian Individual/Organization", 11),
             new Tuple<string, string, int>("LandEquipment","Land Equipment",15),
		     new Tuple<string, string, int>("Installations", "Installations and Infrastructures", 20),
			 new Tuple<string, string, int>("ControlMeasuresPoints", "Control Measures Points",25),
             new Tuple<string, string, int>("ControlMeasuresLines", "Control Measures Lines",25),
             new Tuple<string, string, int>("ControlMeasuresAreas", "Control Measures Areas",25),
             new Tuple<string, string, int>("SeaSurface", "Sea Surface", 30),
             new Tuple<string, string, int>("SeaSubSurface", "Sea SubSurface", 35),
             new Tuple<string, string, int>("SeaSubSurface (Mine Warfare)", "Mine Warfare", 36),
             new Tuple<string, string, int>("Activities", "Activities", 40),

             new Tuple<string, string, int>("METOCPoints (Atmospheric)", "Meteorological and Oceanographic (METOC) Atmospheric Points", 45),
             new Tuple<string, string, int>("METOCPoints (Oceanographic)", "Meteorological and Oceanographic (METOC) Oceanographic Points", 46),
             new Tuple<string, string, int>("METOCLines (Atmospheric)", "Meteorological and Oceanographic (METOC) Atmospheric Lines", 45),
             new Tuple<string, string, int>("METOCLines (Oceanographic)",  "Meteorological and Oceanographic (METOC) Oceanographic Lines", 46),
             new Tuple<string, string, int>("METOCAreas (Atmospheric)", "Meteorological and Oceanographic (METOC) Atmospheric Areas", 45),
             new Tuple<string, string, int>("METOCAreas (Oceanographic)", "Meteorological and Oceanographic (METOC) Oceanographic Areas", 46),

             new Tuple<string, string, int>("SIGINT (Space)", "Signals Intelligence (SIGINT) Space", 50),
             new Tuple<string, string, int>("SIGINT (Air)", "Signals Intelligence (SIGINT) Air", 51),
             new Tuple<string, string, int>("SIGINT (Land)", "Signals Intelligence (SIGINT) Land", 52),
             new Tuple<string, string, int>("SIGINT (Surface)", "Signals Intelligence (SIGINT) Surface", 53),
             new Tuple<string, string, int>("SIGINT (Subsurface)","Signals Intelligence (SIGINT) Subsurface",  54),
             new Tuple<string, string, int>("Cyberspace", "Cyberspace", 60)
        };

		Dictionary<string, string> domains = new Dictionary<string,string>();
		StringBuilder symbolSetClass = new StringBuilder();
	    StringBuilder fieldsBaseClass = new StringBuilder();
		List<Tuple<string, string, int>> supportedSymbolSets = new List<Tuple<string, string, int>>();

	    foreach (var fieldSet in _fieldSets) {
		    var fieldsClassName = ConstructFieldsClassName(fieldSet.Item1);
			var fieldsSchemaName = fieldSet.Item1;
			var fieldsFileName = "";
			try {
				//This can throw!
				fieldsFileName =  this.Host.ResolvePath(ConstructFieldsFileName(fieldSet.Item1));
				var fieldsSymbolSetName = string.Format("symbolset {0:0#}", fieldSet.Item3);
				var fieldsSubType = fieldSet.Item3;
				WriteLine(WriteFieldsClass(fieldsClassName, fieldsSchemaName, fieldsFileName, fieldsSymbolSetName,
			                           fieldsSubType, domains));
			    WriteLine("");
				//save the record of this one
				supportedSymbolSets.Add(fieldSet);
            }
			catch {
				//This fields file is missing
				WriteLine("//Warning missing {0}",ConstructFieldsFileName(fieldSet.Item1));
				WriteLine("//public class {0} skipped",fieldsClassName);
            }
        }

	#>
}

namespace Mil2525.Domains {
    <#
		foreach(var kvp in domains) {
			WriteLine(kvp.Value);
			WriteLine("");
        }
	#>
}

namespace Mil2525.Fields {

    using Mil2525.Domains;

    public partial class SymbolSet {

        /// <summary>
        /// The complete list of supported MIL2525d Symbol Sets
        /// </summary>
        public static Dictionary<string,SymbolSet> SymbolSets = new Dictionary<string, SymbolSet>() {
		<#
		    string sep = "";
			string indent = "\t";
			foreach(var ss in supportedSymbolSets) {
			    Write(indent);
				WriteLine("{0}{1}\"{2}\", new SymbolSet(\"{3}\",\"{4}\",{5}){6}",sep,"{",ss.Item1,
				           ss.Item1, ss.Item2, ss.Item3,"}");
				indent = "\t\t\t";
			    sep = ",";
            }
		#>
        };
    }

    public abstract partial class Fields_Base : INotifyPropertyChanged {

        public static Dictionary<string, Fields_Base> FieldClasses = new Dictionary<string, Fields_Base>() {
		<#
		    sep = "";
			indent = "\t";
			foreach(var ss in supportedSymbolSets) {
				Write(indent);
				WriteLine("{0}{1}\"{2}\", new {3}(){4}",sep,"{",ss.Item1,
				           ConstructFieldsClassName(ss.Item1),"}");
				indent = "\t\t\t";
			    sep = ",";
            }
		#>
        };
    }
}

<#+

        private string ConstructFieldsClassName(string schemaName) {
            schemaName = schemaName.Replace("(", "").Replace(")", "");
            var names = schemaName.Split(new char[] {' '}, StringSplitOptions.RemoveEmptyEntries);

            if (names.Length == 1)
                return "Fields_" + names[0];

            string className = "";
            string sep = "";
            foreach (var name in names) {
                className += (sep + name);
                sep = "_";
            }
            return "Fields_" + className;
        }

        private string ConstructFieldsFileName(string schemaName) {
            var names = schemaName.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            return string.Format("{0}{1}{2}",System.IO.Path.Combine("Fields", "Fields_"), names[0], ".csv");
        }

		private string WriteFieldsClass(string FieldsClassName, string FieldsSchemaName, string FieldsFileName,
		                               string FieldsSymbolSetName, int FieldsSubType, Dictionary<string, string> domains) {
            StringBuilder sb = new StringBuilder();
			StringBuilder ctor = new StringBuilder();
            
            sb.AppendLine("");
			string indent = "\t";
            sb.AppendLine(string.Format("{0}public class {1} : Fields_Base {{", indent, FieldsClassName));
            sb.AppendLine("");
            indent = "\t\t";
            ctor.AppendLine(string.Format("{0}public {1}() {{",indent, FieldsClassName));

            TextFieldParser parser = new TextFieldParser(FieldsFileName);
            parser.TextFieldType = Microsoft.VisualBasic.FileIO.FieldType.Delimited;
            parser.SetDelimiters(",");
            parser.HasFieldsEnclosedInQuotes = true;
            parser.ReadLine();//column headings

            while (!parser.EndOfData) {
                //Process each row
                var row = new Dictionary<string, string>();
                string[] line = parser.ReadFields();
                row["field_name"] = line[0];
                row["field_type"] = line[1];
                row["field_length"] = line[2];
                row["field_alias"] = line[3];
                row["nullability"] = line[4];
                row["field_domain"] = line[5];
                row["field_default"] = line[6];
                row["field_setsubtypes"] = line[7];
                row["field_subtype"] = line[8];
                row["field_notes"] = line[9];

                if (!string.IsNullOrEmpty(row["field_subtype"])) {
                    int subtype = Int32.Parse(row["field_subtype"]);
                    if (subtype != FieldsSubType)
                        continue;
                }

                sb.AppendLine(WriteProperty(row, ctor, FieldsClassName, FieldsSchemaName, FieldsSymbolSetName, 
				                 FieldsSubType, domains));
            }

            indent = "\t\t";
            ctor.AppendLine(string.Format("{0}}}", indent));
            sb.AppendLine(ctor.ToString());
            sb.AppendLine("");
            indent = "\t";
            sb.AppendLine(string.Format("{0}}}", indent));
            return sb.ToString();
        }

        private string WriteProperty(Dictionary<string, string> row, StringBuilder ctor, string FieldsClassName,
		                      string FieldsSchemaName, string FieldsSymbolSetName, int FieldsSubType,
						      Dictionary<string, string> domains) {

			List<string> Categories = new List<string> { "Core", "Optional", "Other" };
            string itemsSourceAttributeFormat = "{0}[ItemsSource(typeof({1}))]\r\n";
            string propDeclarationFormat = "{0}public {1} {2} {{\r\n" +
                                           "{3}\r\n" +
                                           "{0}}}";
            string propGetBodyFormat = "{0}get {{ return _{1}; }}\r\n";
            string propSetBodyFormat = "{0}set {{\r\n" +
                                       "{0}\t_{1} = value;\r\n" +
                                       "{0}\tOnPropertyChanged({2});\r\n" +
                                       "{0}}}";
            string backingFieldDeclarationFormat = "{0}private {1} _{2};\r\n";

            //"{0}[PropertyOrder({1}, UsageContextEnum.Categorized)]\r\n" +

            string headerFormat = "{0}[Category(\"{1}\")]\r\n" +
                                  "{0}[DisplayName(\"{2}\")]\r\n" +
                                  "{0}[Description(\"{3}\")]\r\n" +
                                  "{4}"; //[ItemsSource(typeof(XXXXXItemsSource))]

            string category = "";
            string displayName = row["field_name"];
            string description = row["field_alias"];
            string itemsSource = "";
            string itemsSourceAttribute = "";
            var fieldInfo = GetPropertyFieldInfo(row["field_type"]);

            //property body
			string indent = "\t\t";
            string backingField = string.Format(backingFieldDeclarationFormat, 
                                    indent, fieldInfo.Item1, row["field_name"]);

            indent = "\t\t\t";

            string propertyGet = string.Format(propGetBodyFormat, indent, row["field_name"]);
            string propertySet = string.Format(propSetBodyFormat, indent, row["field_name"], fieldInfo.Item3);
            string propertyBody = string.Format("{0}{1}", propertyGet, propertySet);
            //symbolset is a getter only
            if (row["field_name"] == "symbolset") {
                propertyBody = propertyGet;
            }
            //property declaration and definition
            indent = "\t\t";

            string property = string.Format(propDeclarationFormat, indent, fieldInfo.Item1, row["field_name"],
                propertyBody);

            //Do we have an ItemsSource?
            //special case is "Direction"
            if (!string.IsNullOrEmpty(row["field_domain"])) {

                if (row["field_domain"] != "Direction") {
                    itemsSource = string.Format("{0}ItemsSource", row["field_domain"]);
                    itemsSourceAttribute = string.Format(itemsSourceAttributeFormat, indent, itemsSource);
					if (!domains.ContainsKey(row["field_domain"])) {
						var ClassName = ConstructDomainsClassName(row["field_domain"]);
						string FileName = "";
						try {
							FileName = this.Host.ResolvePath(ConstructDomainsFileName(row["field_domain"]));
							domains.Add(row["field_domain"], WriteDomainClass(ClassName, FileName, row["field_type"]));
                        }
						catch {
							//The domain file is missing
							itemsSourceAttribute = "";
                        }
                    }
                }
            }

            indent = "\t\t\t";

            //Special Handling
            if (row["field_name"] == "identity" || row["field_name"] == "context") {
                ctor.AppendLine(string.Format("{0}_{1} = 0;", indent, row["field_name"]));
				ctor.AppendLine(string.Format("{0}_dictionaryValues[\"{1}\"] = 0;", indent, row["field_name"]));
				ctor.AppendLine(string.Format("{0}_dictionaryFormattedValues[\"{1}\"] = 0;", indent, row["field_name"]));
                category = Categories[0];
            }
            else if (row["field_name"] == "symbolset") {
                ctor.AppendLine(string.Format("{0}_{1} = {2};", indent, row["field_name"], FieldsSubType));
				ctor.AppendLine(string.Format("{0}_dictionaryValues[\"{1}\"] = {2};", indent, row["field_name"], FieldsSubType));
				ctor.AppendLine(string.Format("{0}_dictionaryFormattedValues[\"{1}\"] = {2};", indent, row["field_name"], FieldsSubType));
                ctor.AppendLine(string.Format("{0}_schemaName = \"{1}\";", indent, FieldsSchemaName));
                ctor.AppendLine(string.Format("{0}_symbolSetName = \"{1}\";", indent, FieldsSymbolSetName));
                category = Categories[0];
                itemsSourceAttribute = "";//Even though we have a domain, this is treated as read-only
            }
            else if (row["field_name"] == "symbolentity") {
                ctor.AppendLine(string.Format("{0}_{1} = {2}{3}.Items[0].Value;", indent, row["field_name"],
                    fieldInfo.Item2, itemsSource));
				ctor.AppendLine(string.Format("{0}_dictionaryValues[\"{1}\"] = _{1};", indent, row["field_name"]));
				ctor.AppendLine(string.Format("{0}_dictionaryFormattedValues[\"{1}\"] = _{1};", indent, row["field_name"]));
                category = Categories[0];
            }
            else if (!string.IsNullOrEmpty(itemsSource)) {
                category = Categories[1];
            }
            else {
                category = Categories[2];
            }

            indent = "\t\t";
            //put it together - 
            //backing field,
            //Attributes
            //property declaration and definition
            StringBuilder propBuilder = new StringBuilder();
            propBuilder.AppendLine(backingField);
            propBuilder.Append(string.Format(headerFormat, indent, category, displayName, description,
                itemsSourceAttribute));
            propBuilder.AppendLine(property);
            return propBuilder.ToString();
        }

        private Tuple<string,string,string> GetPropertyFieldInfo(string fieldType) {
            if (fieldType == "Integer" || fieldType == "SmallInteger") {
                return new Tuple<string,string,string>("int","(int)","value");
            }
            else if (fieldType == "Double") {
			    return new Tuple<string,string,string>("double","(double)","value");
            }
            else if (fieldType == "Date") {
				return new Tuple<string,string,string>("DateTime","(DateTime)",
					 "value, formattedValue: string.Format(\"new DateTime({0},{1},{2})\", value.Year, value.Month, value.Day)");
            }
            return new Tuple<string,string,string>("string","(string)",
			     string.Format("value, formattedValue: string.Format(\"{0}\"{{0}}{0}\"\",value)", "\\"));
        }

		#region Domains

		private string ConstructDomainsClassName(string domainName) {
            return domainName + "ItemsSource";
        }

        private string ConstructDomainsFileName(string domainName) {
            return string.Format("{0}{1}{2}",
                System.IO.Path.Combine("Domains", "Coded_Domain_"), domainName, ".csv");
        }


		private string WriteDomainClass(string ClassName, string FileName, string DomainValueType) {
            
            StringBuilder sb = new StringBuilder();
            string indent = "\t";
            sb.AppendLine(string.Format("{0}public class {1} : IItemsSource {{", indent, 
                               ClassName));
            sb.AppendLine("");
            indent = "\t\t";
            sb.AppendLine(string.Format("{0}public static ItemCollection Items = new {1}().GetValues();",
                indent, ClassName));
            sb.AppendLine("");
            sb.AppendLine(string.Format("{0}public ItemCollection GetValues() {{", indent));
            indent = "\t\t\t";
            sb.AppendLine(string.Format(
                "{0}var items = new Xceed.Wpf.Toolkit.PropertyGrid.Attributes.ItemCollection();", indent));

            TextFieldParser parser = new TextFieldParser(FileName);
            parser.TextFieldType = Microsoft.VisualBasic.FileIO.FieldType.Delimited;
            parser.SetDelimiters(",");
            parser.HasFieldsEnclosedInQuotes = true;
            parser.ReadLine();//column headings

            var formatString = FormatString(DomainValueType);
            
            while (!parser.EndOfData) {
                //Process each row
                var row = new Dictionary<string, string>();
                string[] line = parser.ReadFields();
                row["name"] = line[0];
                row["value"] = line[1];
                sb.AppendLine(string.Format(formatString, indent, row["value"], row["name"]));
            }

            sb.AppendLine(string.Format("{0}return items;", indent));
            indent = "\t\t";
            sb.AppendLine(string.Format("{0}}}", indent));
            indent = "\t";
            sb.AppendLine(string.Format("{0}}}", indent));
            return sb.ToString();
        }

		private string FormatString(string domainValueType) {
            if (domainValueType == "Integer" || 
                domainValueType == "SmallInteger" ||
                domainValueType == "Double") {
                return "{0}items.Add({1}, \"{1} - {2}\");";
            }
            else {
                return "{0}items.Add(\"{1}\", \"'{1}' - {2}\");"; 
            }
        }

		#endregion Domains
#>

